# Title bar/prompt
# TODO: encapsulate this better in functions once I learn shell functions!
# TODO: Think about adding git branch: http://www.gnegg.ch/2008/04/git-branch-in-zsh-prompt/
#   and maybe using WATCHFMT/LOGCHECK. MAILCHECK, or TMOUT/TRAPALRM somehow to cache it?

setopt prompt_subst
setopt transient_rprompt

blue=$'%{\e[34m%}' 		# %{ chars don't add to length of prompt %}
red=$'%{\e[31m%}'
black=$'%{\e[30m%}'
magenta=$'%{\e[35m%}'

title_L=$'%{\e]2;'		# \e]2;title bar\a
title_R=$'\a%}'
title_text="%m:%~"		# %m = machine name, %~ = current directory
title_full="$title_L$title_text$title_R"

macname=$(uname -n)
if [[ "$HOSTNAME" = "micro.home.jay.fm" ]]; then
    prompt_L="$red%U"		# %Uunderlined-text%u
elif [[ $macname = "macbook.home.jay.fm" ]]; then
    prompt_L="$magenta%U"
elif [[ $macname = "macbook2-wired.home.jay.fm" ]]; then
    prompt_L="$magenta%U"
elif [[ $macname = "macpro.home.jay.fm" ]]; then
    prompt_L="$blue%U"
else
    prompt_l="$black%U"
fi

prompt_R="$black%u"
prompt_text="%1~"			# %1~ = rightmost component of current directory

if [[ $EUID = 0 ]]; then
    prompt_L="$prompt_L%B"
    prompt_R="$prompt_R%b"
    prompt_state="$red%B%#%b$black"
else
    prompt_state="%#"
fi

prompt_full="$prompt_L$prompt_text$prompt_R$prompt_state "
# TODO: I like the status idea, but annoying that it doesn't reset itself
# prompt_status='%(?..(%?%) )' 
export PS1=$'$title_full$prompt_status$prompt_full'
export PS4='+%N:%i:%_>'	# script debugging
